#include "stdafx.h"

#include <iostream>
#include <cmath>

using namespace std;

int main() {

	setlocale(0, "rus");

	double a, b, dx, e, cv, s = 0;

	std::cout << "\tВведите интервал [a, b]: ";
	std::cout << "\n\ta = ";
	std::cin >> a;
	std::cout << "\tb = ";
	std::cin >> b;

	std::cout << "\tВведите шаг: ";
	std::cout << "\n\tdX = ";
	std::cin >> dx;

	std::cout << "\tВведите необходимую точность: ";
	std::cout << "\n\tE = ";
	std::cin >> e;

	double pr, d; //pr хранить результат вычисления логарифма для каждого х на интервале от а до b, d прост помощник для формулы 
	while (fabs(a) < b) { //на интервале от a до b 
		if (fabs(a) > 1) {
			pr = 0; // сбросить результат предущего значения
			d = 1; // тоже сбросить чтоб для нового х использовать
			for (;;) // бесконечный цикл искать результат логарифма пока заданной точности недостигнет
			{ // скобочка
				cv = 1.0 / (pow(a, d)*d); // формула из задания
				d += 2; //чтоб было 1/а потом 1/(3*a^3) дальше 1/(5*a^5) и тд
				pr += cv; // прибавление нового значения к результату логарифма, знаешь же как его по ряду искать там складываешь все время в итоге и получаешь число близкое к его значению
				if (cv < e) // если точность достигнута новый элемент меньше необходимой точности
				{
					std::cout << "\n\tA = " << a << "\tpr =" << pr * 2 << "\tln = " << log((a + 1) / (a - 1)); // это просто промежуточный результат вычисления каждого элемента для суммы можно и убрать
					break; // выходим отсюдога
				}
			}
			s += pr * 2; //добавляем к сумме двоечка тоже из формулы
		}
		a += dx; // переходим к новому икс 
				 // и так пока а не достигнет b 
	}
	std::cout << "\tСумма ряда =  " << s;
	
	return 0;
}
